# Electron Headless Browser 中文使用文档

## 快速开始

### 1. 启动应用
```bash
cd app
npm start
```

### 2. 验证服务运行
```bash
curl http://127.0.0.1:3456/rpc -d '{"method": "ping"}'
# 应该返回: {"ok": true, "result": "pong"}
```

### 3. 创建第一个浏览器窗口
```bash
curl -X POST http://127.0.0.1:3456/rpc \
  -H "Content-Type: application/json" \
  -d '{
    "method": "openWindow",
    "params": {
      "account_index": 1,
      "url": "https://www.baidu.com"
    }
  }'
```

## 核心概念

### 账户隔离 (Account Isolation)
每个账户都有独立的浏览器上下文：
- **账户索引**: `account_index` (整数，从 0 开始)
- **沙盒隔离**: 不同账户的窗口完全隔离
- **资源共享**: 同账户窗口在相同域名下共享 cookies 和缓存

### 窗口管理
所有操作都需要指定 `win_id`：
1. 使用 `list_pages` 获取活跃窗口列表
2. 从结果中选择目标窗口的 `win_id`
3. 在后续 API 调用中传递该 `win_id`

## OpenCode MCP 集成

### 什么是 MCP？
Model Context Protocol (MCP) 是一个用于连接 AI 模型到工具和数据源的协议。通过 MCP，你可以在 OpenCode 编辑器中直接使用浏览器自动化功能。

### 集成步骤

1. **安装依赖**
```bash
cd app
npm install @modelcontextprotocol/sdk zod
```

2. **配置 OpenCode**
将 `mcp-config.json` 放置在项目根目录：
```json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "electron-headless-ptools": {
      "type": "local",
      "command": ["node", "opencode-mcp-server.js"],
      "description": "Playwright风格的浏览器自动化工具",
      "capabilities": {
        "tools": {
          "listChanged": true
        }
      }
    }
  }
}
```

3. **启动服务**
```bash
# 启动 Electron 应用
cd app && npm start

# 在另一个终端测试 MCP
node test-opencode-mcp.js
```

4. **在 OpenCode 中使用**
```javascript
// 创建浏览器窗口
await mcp.tools.call('new_page', {
  url: 'https://example.com',
  account_index: 1
});

// 自动化操作
await mcp.tools.call('click', { win_id: 1, x: 100, y: 200 });
await mcp.tools.call('fill', {
  win_id: 1,
  selector: '#username',
  value: 'testuser'
});

// 获取截图
await mcp.tools.call('take_screenshot', { win_id: 1 });
```

### 测试 MCP 功能
```bash
# 运行完整测试
node test-opencode-mcp.js

# 预期输出:
🧪 开始 OpenCode MCP 服务器完整测试
✅ MCP 服务器启动
✅ 工具列表获取
✅ 工具调用测试
🎉 所有测试通过！
```

## API 参考

### 窗口管理

#### 创建窗口
```javascript
POST /rpc
{
  "method": "openWindow",
  "params": {
    "account_index": 1,      // 账户索引
    "url": "https://example.com",
    "options": {             // 窗口选项
      "width": 1280,
      "height": 720
    },
    "others": {              // 额外选项
      "userAgent": "Custom Bot/1.0",
      "proxy": "socks5://127.0.0.1:9050"
    }
  }
}
```

#### 列出窗口
```javascript
POST /rpc
{
  "method": "getWindows"
}
// 返回按账户分组的窗口列表
```

#### 关闭窗口
```javascript
POST /rpc
{
  "method": "closeWindow",
  "params": {
    "win_id": 1
  }
}
```

### 页面操作

#### 导航到 URL
```javascript
POST /rpc
{
  "method": "loadURL",
  "params": {
    "win_id": 1,
    "url": "https://new-page.com"
  }
}
```

#### 执行 JavaScript
```javascript
POST /rpc
{
  "method": "executeJavaScript",
  "params": {
    "win_id": 1,
    "code": "(() => { return document.title; })()"
  }
}
```

#### 获取截图
```javascript
GET /screenshot?id=1
# 返回 PNG 图像
```

### 输入自动化

#### 点击坐标
```javascript
POST /rpc
{
  "method": "sendInputEvent",
  "params": {
    "win_id": 1,
    "inputEvent": {
      "type": "mouseDown",
      "x": 100,
      "y": 200,
      "button": "left"
    }
  }
}
```

#### 填写表单
```javascript
POST /rpc
{
  "method": "executeJavaScript",
  "params": {
    "win_id": 1,
    "code": "document.querySelector('#username').value = 'testuser';"
  }
}
```

### 会话管理

#### 设置 User Agent
```javascript
POST /rpc
{
  "method": "setUserAgent",
  "params": {
    "win_id": 1,
    "userAgent": "Mozilla/5.0 (Custom Bot)"
  }
}
```

#### Cookie 管理
```javascript
// 导入 cookies
POST /rpc
{
  "method": "importCookies",
  "params": {
    "win_id": 1,
    "cookies": [{
      "name": "session_id",
      "value": "abc123",
      "domain": ".example.com"
    }]
  }
}

// 导出 cookies
POST /rpc
{
  "method": "exportCookies",
  "params": {
    "win_id": 1
  }
}
```

## MCP 集成

### 什么是 MCP？
Model Context Protocol (MCP) 是一个用于连接 AI 模型到工具和数据源的协议。

### 可用工具

#### 导航工具
- `new_page` - 创建新浏览器窗口
- `close_page` - 关闭浏览器窗口
- `navigate_page` - 导航到指定 URL
- `list_pages` - 列出所有活跃窗口

#### 输入工具
- `click` - 点击指定坐标
- `fill` - 填写表单字段
- `press_key` - 按下键盘按键

#### 调试工具
- `evaluate_script` - 执行 JavaScript 代码
- `take_screenshot` - 截取窗口截图

#### 网络工具
- `get_network_request` - 获取网络请求详情
- `list_network_requests` - 列出所有网络请求

### MCP 配置
创建 `mcp-config.json`:
```json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "electron-headless-ptools": {
      "type": "local",
      "command": ["curl", "-X", "POST", "http://127.0.0.1:3456/mcp", "-H", "Content-Type: application/json", "-d", "@-"],
      "description": "Playwright风格的浏览器自动化工具"
    }
  }
}
```

## 实战示例

### 网页数据抓取
```javascript
async function scrapeData(url) {
  // 1. 创建窗口
  const createResponse = await fetch('/rpc', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      method: 'openWindow',
      params: { account_index: 1, url }
    })
  });

  const { result: { id: winId } } = await createResponse.json();

  // 2. 等待页面加载
  await new Promise(resolve => setTimeout(resolve, 2000));

  // 3. 提取数据
  const dataResponse = await fetch('/rpc', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      method: 'executeJavaScript',
      params: {
        win_id: winId,
        code: `(() => {
          const titles = Array.from(document.querySelectorAll('h2'))
            .map(h2 => h2.textContent);
          return titles;
        })()`
      }
    })
  });

  const { result: titles } = await dataResponse.json();
  return titles;
}
```

### 表单自动化
```javascript
async function fillLoginForm(winId, credentials) {
  // 填写用户名
  await fetch('/rpc', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      method: 'executeJavaScript',
      params: {
        win_id: winId,
        code: `document.querySelector('#username').value = '${credentials.username}';`
      }
    })
  });

  // 填写密码
  await fetch('/rpc', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      method: 'executeJavaScript',
      params: {
        win_id: winId,
        code: `document.querySelector('#password').value = '${credentials.password}';`
      }
    })
  });

  // 提交表单
  await fetch('/rpc', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      method: 'executeJavaScript',
      params: {
        win_id: winId,
        code: `document.querySelector('form').submit();`
      }
    })
  });
}
```

### 多账户自动化
```javascript
async function runMultiAccountTasks() {
  const accounts = [
    { index: 1, url: 'https://site1.com', task: task1 },
    { index: 2, url: 'https://site2.com', task: task2 },
    { index: 3, url: 'https://site3.com', task: task3 }
  ];

  const results = [];

  for (const account of accounts) {
    // 为每个账户创建隔离的窗口
    const response = await fetch('/rpc', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        method: 'openWindow',
        params: {
          account_index: account.index,
          url: account.url
        }
      })
    });

    const { result: { id: winId } } = await response.json();

    // 执行账户特定的任务
    const result = await account.task(winId);
    results.push(result);

    // 可选择关闭窗口以释放资源
    // await closeWindow(winId);
  }

  return results;
}
```

## 故障排除

### 常见问题

#### 窗口创建失败
```bash
# 检查账户索引是否有效
curl -X POST http://127.0.0.1:3456/rpc \
  -d '{"method": "getWindows"}'
```

#### JavaScript 执行失败
- 使用 IIFE 包装代码: `(() => { /* code */ })()`
- 检查 DOM 元素是否存在
- 添加错误处理

#### 网络超时
- 增加等待时间
- 检查网络连接
- 验证代理设置

### 调试技巧

#### 启用开发者工具
```javascript
POST /rpc
{
  "method": "openDevTools",
  "params": {
    "win_id": 1
  }
}
```

#### 查看网络请求
```javascript
POST /rpc
{
  "method": "getRequests",
  "params": {
    "win_id": 1
  }
}
```

#### 获取系统信息
```javascript
POST /rpc
{
  "method": "info"
}
```

## 架构优势

### 模块化设计
- **核心模块**: 处理应用生命周期和窗口管理
- **服务器模块**: 处理 HTTP 请求和 MCP 集成
- **服务模块**: 提供业务逻辑 (截图、网络监控)
- **工具模块**: 共享的辅助函数

### 环境分离
- **Node.js**: 主进程运行的核心逻辑
- **浏览器**: 渲染进程运行的内容脚本

### 扩展性
- 易于添加新的自动化工具
- 支持多种协议 (HTTP RPC + MCP)
- 模块化架构支持未来功能扩展

## 性能优化

### 资源管理
- 及时关闭不需要的窗口
- 使用账户隔离避免资源冲突
- 监控内存使用情况

### 网络优化
- 使用代理进行请求路由
- 实现请求缓存策略
- 批量处理相似操作

### 并发控制
- 限制同时运行的窗口数量
- 实现请求队列机制
- 使用连接池管理资源

---

这个文档提供了 Electron Headless Browser 的完整使用指南。从基础设置到高级自动化功能，应有尽有。如有问题，请参考故障排除部分或查看源代码中的注释。